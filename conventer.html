<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>MP3 в OGG Конвертер | Retrowave</title>

    <!-- 
        ВАЖНО: Эти заголовки необходимы для работы ffmpeg.wasm в браузere.
        Они разрешают использование SharedArrayBuffer, что критично для производительности.
    -->
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

    <!-- Подключение Tailwind CSS для стилей -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Подключение шрифта Roboto -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-image: url('https://media1.tenor.com/m/Ihk_3o5l0WkAAAAC/sun.gif');
            background-size: cover;
            background-position: center center;
            background-attachment: fixed;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .text-gradient {
            background: linear-gradient(to right, #a5b4fc, #f9a8d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        .lds-ring {
          display: inline-block;
          position: relative;
          width: 20px;
          height: 20px;
        }
        .lds-ring div {
          box-sizing: border-box;
          display: block;
          position: absolute;
          width: 16px;
          height: 16px;
          margin: 2px;
          border: 2px solid #fff;
          border-radius: 50%;
          animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
          border-color: #fff transparent transparent transparent;
        }
        .lds-ring div:nth-child(1) {
          animation-delay: -0.45s;
        }
        .lds-ring div:nth-child(2) {
          animation-delay: -0.3s;
        }
        .lds-ring div:nth-child(3) {
          animation-delay: -0.15s;
        }
        @keyframes lds-ring {
          0% {
            transform: rotate(0deg);
          }
          100% {
            transform: rotate(360deg);
          }
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-300">

    <div class="container mx-auto max-w-4xl p-4 md:p-8 my-8">
        <div class="bg-slate-900/80 backdrop-blur-sm rounded-2xl border border-slate-700 shadow-2xl shadow-pink-500/10 overflow-hidden">
            <div class="p-6 md:p-8">

                <header class="text-center">
                    <h1 class="text-4xl md:text-5xl font-bold text-gradient tracking-wider">
                        MP3 в OGG Конвертер
                    </h1>
                    <p class="text-slate-400 mt-2">Ретро-конвертер на базе FFMPEG</p>
                </header>

                <hr class="border-slate-700/50 my-8">
                
                <div id="main-interface" class="space-y-6">
                    <!-- Шаг 1: Выбор файла -->
                    <div>
                        <h2 class="text-2xl font-semibold text-slate-200 flex items-center gap-3">
                            <span class="flex items-center justify-center w-8 h-8 rounded-full bg-pink-500 text-white font-bold">1</span>
                            Выберите MP3 файл
                        </h2>
                        <div class="mt-4 p-6 bg-slate-800/50 rounded-lg border border-slate-700">
                             <label for="file-upload" class="relative cursor-pointer w-full flex justify-center items-center px-6 py-10 border-2 border-slate-600 border-dashed rounded-lg bg-slate-700/50 hover:border-pink-400 transition-colors">
                                <div class="text-center">
                                    <svg class="mx-auto h-12 w-12 text-slate-500" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4V12a4 4 0 014-4h12l4 4h12a4 4 0 014 4zm-12 4l-4-4m0 0l-4 4m4-4v12" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
                                    <span class="mt-2 block font-semibold text-slate-300">Нажмите, чтобы загрузить</span>
                                    <span class="block text-xs text-slate-400">или перетащите файл сюда</span>
                                </div>
                                <input id="file-upload" name="file-upload" type="file" class="sr-only" accept=".mp3,audio/*">
                            </label>
                            <p id="file-name" class="mt-4 text-center text-pink-400 font-medium truncate"></p>
                        </div>
                    </div>
                    
                    <!-- Шаг 2: Конвертация -->
                    <div>
                        <h2 class="text-2xl font-semibold text-slate-200 flex items-center gap-3">
                             <span class="flex items-center justify-center w-8 h-8 rounded-full bg-indigo-500 text-white font-bold">2</span>
                             Начать процесс
                        </h2>
                        <div class="mt-4 flex flex-col items-center gap-4">
                            <button id="convert-btn" type="button" disabled class="w-full md:w-auto flex items-center justify-center gap-2 bg-blue-600 hover:bg-blue-700 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:shadow-blue-500/50 transition-all duration-300">
                                <span id="convert-btn-text">Загрузка движка...</span>
                                <div id="loader" class="hidden lds-ring"><div></div><div></div><div></div><div></div></div>
                            </button>
                             <a id="download-btn" href="#" download="converted.ogg" class="hidden w-full md:w-auto flex items-center justify-center gap-2 bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:shadow-teal-500/50 transition-all duration-300">
                                <span>Скачать OGG</span>
                            </a>
                        </div>
                    </div>
                    <div id="status-container" class="pt-4 text-center">
                        <p id="status-text" class="text-slate-400 font-mono text-sm h-5"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- ЧАСТЬ 1: КОД БИБЛИОТЕКИ FFMPEG.WASM ---
        // Весь код библиотеки ffmpeg.min.js вставлен сюда, чтобы избежать внешних запросов и проблем с CORS.
        var FFmpeg; (() => { var e = { 783: (e, t, r) => { "use strict"; r.d(t, { Z: () => i }); var n = r(586), o = r.n(n), a = r(879), s = r.n(a), i = (0, o().cp)({ name: "ffmpeg", base: "https://unpkg.com/@ffmpeg/core@0.12.6/dist", wasm: ["ffmpeg-core.wasm"], js: ["ffmpeg-core.js"], worker: ["ffmpeg-core.worker.js"] }, { ...s() }) }, 586: (e, t, r) => { "use strict"; r.d(t, { KC: () => u, cp: () => c }); var n = r(885), o = r.n(n), a = (e, t) => { if (!t.has(e)) throw new TypeError("attempted to get private field on non-instance"); return t.get(e) }, s = new WeakMap, i = new WeakMap, c = e => { let { name: t, base: r, wasm: n, js: c, worker: u } = e, l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, d = new AbortController; return { ...l, name: t, corePath: "".concat(r, "/").concat(c), wasmPath: "".concat(r, "/").concat(n), workerPath: "".concat(r, "/").concat(u), O0: d, l0: d.signal, v0: async e => { let { O0: t, l0: n, corePath: o, wasmPath: s, workerPath: c, mainName: u = "main", exit: l, logger: d, progress: p } = e, f = "undefined" != typeof process && "true" === process.env.FFMPEG_WASM_DEBUG, h = await (0, a.Z)(o, "text", n); if (null !== h) { let e = "\nvar ffmpeg_wasm_id = ".concat(Math.round(1e11 * Math.random()), ";\nvar ffmpeg_wasm_worker_path = '").concat(c, "';\n"); return URL.createObjectURL(new Blob([e, h], { type: "text/javascript" })) } throw Error("failed to load ffmpeg-core.js") }, C0: async e => { let { l0: t, wasmPath: r } = e; return (0, a.Z)(r, "arrayBuffer", t) } } }; class u { constructor(e) { s.set(this, { writable: !0, value: void 0 }), i.set(this, { writable: !0, value: void 0 }), o()(this, i, {}), o()(this, s, e) } get(e) { return a(i, this)[e] } set(e, t) { a(i, this)[e] = t } getFullOptions() { return a(s, this) } } }, 885: e => { e.exports = function(e, t, r) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); t.set(e, r) } }, 879: e => { "function" != typeof atob && (e.exports = r => { let n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o = (t, r) => (e[t] = r, e), a = (e, t, r) => { let o = e.charCodeAt(t); return o > 255 ? r : (e = n.indexOf(e.charAt(t)), o > 64 && o < 91 && (e = o - 65), o > 96 && o < 123 && (e = o - 97 + 26), o > 47 && o < 58 && (e = o - 48 + 52), 43 === o && (e = 62), 47 === o && (e = 63), e) }; return function(e) { e = e.replace(/[^A-Za-z0-9\+\/]/g, ""); let t = e.length, n = t % 4, s = (0 === t ? 0 : 57 === e.charCodeAt(t - 1) ? 2 : 57 === e.charCodeAt(t - 2) ? 1 : 0) || (0 === n ? 0 : n > 1 ? 4 - n : 0), i = new Uint8Array(3 * t / 4 - s), c = 0, u = 0, l = 0; for (; c < t;) { let t = a(e, c++, r), n = a(e, c++, r), d = a(e, c++, r), p = a(e, c++, r); o(u++, t << 2 | n >> 4), o(u++, (15 & n) << 4 | d >> 2), o(u++, (3 & d) << 6 | 63 & p) } return 2 === s ? (i = i.slice(0, i.length - 2), i) : 1 === s ? (i = i.slice(0, i.length - 1), i) : i }(r) }) }, 649: (e, t, r) => { "use strict"; r.d(t, { createFFmpeg: () => g, fetchFile: () => h }); var n, o, a = r(885), s = r.n(a), i = (e, t) => { if (!t.has(e)) throw new TypeError("attempted to get private field on non-instance"); return t.get(e) }, c = new WeakMap, u = new WeakMap, l = new WeakMap, d = new WeakMap; let p = (() => { let e = !1; return () => (e || (console.log("createFFmpeg is loaded in development mode. If you are building production app, please use `const { createFFmpeg, fetchFile } from '@ffmpeg/ffmpeg/dist/ffmpeg.min.js';`"), e = !0), { Z: r(783).Z }) })(); class f { constructor(e) { c.set(this, { writable: !0, value: null }), u.set(this, { writable: !0, value: !1 }), l.set(this, { writable: !0, value: [] }), d.set(this, { writable: !0, value: () => { } }), s()(this, d, () => { }), s()(this, l, []), s()(this, u, !1), s()(this, c, null); let t = p().Z; for (let r in e) t[r] = e[r]; a(this, "ffmpeg", t), a(this, "options", new r(586).KC(a(this, "ffmpeg"))), a(this, "log", !!e.log), a(this, "progress", e.progress || (() => { })), a(this, "logger", e.logger || (e => { a(this, "log") && console.log(e) })) } async load() { a(this, "logger")({ type: "info", message: "load ffmpeg-core" }), i(this, u) || (await this.g0(), i(this, c, (e => { let { l0: t, v0: n, C0: o, progress: s } = e; return new Promise((async (e, i) => { let c = await n(a(this, "ffmpeg")), u = new Worker(c, { type: void 0 }); u.onmessage = async t => { let { type: n, data: c } = t.data, d = a(this, "ffmpeg"); switch (n) { case "g0": await u.postMessage({ type: "h0", data: { ...d, wasm: await o(d) } }); break; case "M0": e(u); break; case "L0": i(c); break; case "T0": case "U0": a(this, "logger")(t.data); break; case "P0": s(c) } }, u.onerror = (e => { i(e) }), t.addEventListener("abort", (() => { u.terminate() })) })) })(a(this, "ffmpeg"))), i(this, u, !0), a(this, "logger")({ type: "info", message: "ffmpeg-core loaded" })) } getFS() { return i(this, c).FS } FS(e, t) { for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)n[o - 2] = arguments[o]; return i(this, c).FS(e, t, ...n) } run() { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return i(this, c).p0(t), a(this, "logger")({ type: "info", message: "run ffmpeg command: ".concat(t.join(" ")) }), i(this, c).S.apply(i(this, c), [a(this, "options").get("mainName"), t]) } exit() { a(this, "logger")({ type: "info", message: "exit ffmpeg" }), i(this, c).exit() } setProgress(e) { a(this, "progress", e), i(this, c) && (i(this, c).onMessage = (t => { "P0" === t.data.type && a(this, "progress")(t.data.data) })) } setLogger(e) { a(this, "logger", e), i(this, c) && (i(this, c).onMessage = (t => { "U0" === t.data.type && a(this, "logger")(t.data) })) } setLogging(e) { a(this, "log", e) } isLoaded() { return i(this, u) } } h = async e => { let t = e; "string" == typeof e && (t = await (0, r(879).Z)(e)); let n = new Uint8Array(await (async e => new Promise((t => { let r = new FileReader; r.onload = (e => { t(e.target.result) }), r.readAsArrayBuffer(e) })))(new Blob([t]))); return n }, g = function(e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)r[n - 1] = arguments[n]; return new f(e, ...r) } }, 879: (e, t, r) => { "use strict"; r.d(t, { Z: () => a }); var n = new WeakMap, o = new WeakMap; let a = async function(e, t) { let a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : (new AbortController).signal; if (void 0 !== self.fetch) { let s = await self.fetch(e, { signal: a }); if ("arrayBuffer" === t) return await s.arrayBuffer(); if ("text" === t) return await s.text() } if ("undefined" == typeof r.g || "undefined" == typeof r.g.require) return null; let s = r.g.require("fs"), i = r.g.require("path"); return new Promise(((r, n) => { a.addEventListener("abort", (() => { n("fetch request aborted.") })), s.readFile(i.resolve(e), ((e, a) => e ? n(e) : "text" === t ? r(a.toString()) : r(a.buffer))) })) } } }, t = {}; function r(n) { var o = t[n]; if (void 0 !== o) return o.exports; var a = t[n] = { exports: {} }; return e[n](a, a.exports, r), a.exports } FFmpeg = r(649) })();

        // --- ЧАСТЬ 2: ЛОГИКА ПРИЛОЖЕНИЯ ---
        document.addEventListener('DOMContentLoaded', () => {
            const { createFFmpeg, fetchFile } = FFmpeg;

            const statusText = document.getElementById('status-text');
            const convertBtn = document.getElementById('convert-btn');
            const convertBtnText = document.getElementById('convert-btn-text');
            const loader = document.getElementById('loader');
            const fileUploadInput = document.getElementById('file-upload');
            const fileNameDisplay = document.getElementById('file-name');
            const downloadBtn = document.getElementById('download-btn');

            let selectedFile = null;
            let ffmpeg; 
            let ffmpegLoaded = false;

            const loadFFmpeg = async () => {
                convertBtnText.textContent = 'Загрузка...';
                loader.classList.remove('hidden');
                statusText.textContent = 'Загрузка ядра FFMPEG (до ~30МБ)...';
                
                ffmpeg = createFFmpeg({
                    log: true,
                    // Используем CDN, который предоставляет необходимые CORS-заголовки
                    corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js',
                });
                await ffmpeg.load();
                ffmpegLoaded = true;
                statusText.textContent = 'Движок готов. Выберите файл.';
                convertBtnText.textContent = 'Выберите файл';
                loader.classList.add('hidden');
            };
            
            // Начинаем загрузку ffmpeg сразу
            loadFFmpeg().catch(err => {
                console.error("FFmpeg loading error:", err);
                statusText.textContent = 'Ошибка загрузки FFMPEG. Обновите страницу.';
                convertBtnText.textContent = 'Ошибка загрузки';
                loader.classList.add('hidden');
            });

            const handleFileSelect = (e) => {
                const files = e.target.files || e.dataTransfer?.files;
                if (!files || files.length === 0) {
                    selectedFile = null;
                    fileNameDisplay.textContent = '';
                    statusText.textContent = 'Файл не выбран.';
                    convertBtn.disabled = true;
                    return;
                }
                selectedFile = files[0];
                 if (!selectedFile.type.startsWith('audio/')) {
                    statusText.textContent = 'Ошибка: Пожалуйста, выберите аудиофайл.';
                    fileUploadInput.value = '';
                    selectedFile = null;
                    fileNameDisplay.textContent = '';
                    convertBtn.disabled = true;
                    return;
                }
                fileNameDisplay.textContent = selectedFile.name;
                statusText.textContent = `Готов к конвертации: ${selectedFile.name}`;
                downloadBtn.classList.add('hidden');
                convertBtn.disabled = !ffmpegLoaded;
                if (ffmpegLoaded) {
                    convertBtnText.textContent = 'Конвертировать';
                }
            };

            const convertFile = async () => {
                if (!selectedFile || !ffmpegLoaded) {
                    statusText.textContent = ffmpegLoaded ? 'Сначала выберите файл.' : 'FFMPEG еще не загружен.';
                    return;
                }

                convertBtn.disabled = true;
                loader.classList.remove('hidden');
                convertBtnText.textContent = 'Конвертация...';
                downloadBtn.classList.add('hidden');
                statusText.textContent = 'Чтение файла...';

                try {
                    const inputFileName = selectedFile.name;
                    const outputFileName = 'output.ogg';
                    
                    ffmpeg.FS('writeFile', inputFileName, await fetchFile(selectedFile));

                    statusText.textContent = 'Запуск конвертации... Это может занять время.';
                    
                    // Команда для ffmpeg: -i [входной_файл] -c:a [кодек] [выходной_файл]
                    // libvorbis - это кодек для OGG
                    await ffmpeg.run('-i', inputFileName, '-c:a', 'libvorbis', outputFileName);

                    statusText.textContent = 'Создание файла для скачивания...';
                    const data = ffmpeg.FS('readFile', outputFileName);
                    
                    const url = URL.createObjectURL(new Blob([data.buffer], { type: 'audio/ogg' }));
                    downloadBtn.href = url;
                    
                    const originalName = selectedFile.name.split('.').slice(0, -1).join('.');
                    downloadBtn.download = `${originalName}.ogg`;
                    
                    downloadBtn.classList.remove('hidden');
                    statusText.textContent = 'Готово! Файл можно скачивать.';

                } catch (error) {
                    console.error("FFmpeg conversion error:", error);
                    statusText.textContent = 'Произошла ошибка во время конвертации.';
                } finally {
                    convertBtn.disabled = false;
                    loader.classList.add('hidden');
                    convertBtnText.textContent = 'Конвертировать';
                }
            };

            // Drag and drop
            const dropZone = fileUploadInput.parentElement;
            ['dragover', 'dragleave', 'drop'].forEach(eventName => dropZone.addEventListener(eventName, e => e.preventDefault()));
            dropZone.addEventListener('dragover', () => dropZone.classList.add('border-pink-400'));
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('border-pink-400'));
            dropZone.addEventListener('drop', e => {
                dropZone.classList.remove('border-pink-400');
                fileUploadInput.files = e.dataTransfer.files;
                handleFileSelect({ target: fileUploadInput });
            });

            fileUploadInput.addEventListener('change', handleFileSelect);
            convertBtn.addEventListener('click', convertFile);
        });
    </script>
</body>
</html>
